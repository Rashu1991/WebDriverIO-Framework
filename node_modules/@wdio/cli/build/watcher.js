"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _chokidar = _interopRequireDefault(require("chokidar"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _lodash = _interopRequireDefault(require("lodash.pickby"));

var _lodash2 = _interopRequireDefault(require("lodash.flattendeep"));

var _lodash3 = _interopRequireDefault(require("lodash.union"));

var _launcher = _interopRequireDefault(require("./launcher.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _logger.default)('@wdio/cli:watch');

class Watcher {
  constructor(configFile, args) {
    log.info('Starting launcher in watch mode');
    this.launcher = new _launcher.default(configFile, args, true);
    this.args = args;
    const specs = this.launcher.configParser.getSpecs();
    const capSpecs = this.launcher.isMultiremote ? [] : (0, _lodash3.default)((0, _lodash2.default)(this.launcher.configParser.getCapabilities().map(cap => cap.specs || [])));
    this.specs = [...specs, ...capSpecs];
    this.isRunningTests = false;
  }

  async watch() {
    _chokidar.default.watch(this.specs, {
      ignoreInitial: true
    }).on('add', this.getFileListener()).on('change', this.getFileListener());

    const {
      filesToWatch
    } = this.launcher.configParser.getConfig();

    if (filesToWatch.length) {
      _chokidar.default.watch(filesToWatch, {
        ignoreInitial: true
      }).on('add', this.getFileListener(false)).on('change', this.getFileListener(false));
    }

    await this.launcher.run();
    const workers = this.getWorkers();
    Object.values(workers).forEach(worker => worker.on('exit', () => {
      if (Object.values(workers).find(w => w.isBusy)) {
        return;
      }

      this.launcher.interface.finalise();
    }));
  }

  getFileListener(passOnFile = true) {
    return spec => this.run(Object.assign({}, this.args, passOnFile ? {
      spec
    } : {}));
  }

  getWorkers(pickByFn, includeBusyWorker) {
    let workers = this.launcher.runner.workerPool;

    if (typeof pickByFn === 'function') {
      workers = (0, _lodash.default)(workers, pickByFn);
    }

    if (!includeBusyWorker) {
      workers = (0, _lodash.default)(workers, worker => !worker.isBusy);
    }

    return workers;
  }

  run(params = {}) {
    const workers = this.getWorkers(params.spec ? worker => worker.specs.includes(params.spec) : null);

    if (Object.keys(workers).length === 0) {
      return;
    }

    this.launcher.interface.totalWorkerCnt = Object.entries(workers).length;
    this.cleanUp();

    for (const [, worker] of Object.entries(workers)) {
      const {
        cid,
        caps,
        specs,
        sessionId
      } = worker;
      const args = Object.assign({
        sessionId
      }, params);
      worker.postMessage('run', args);
      this.launcher.interface.emit('job:start', {
        cid,
        caps,
        specs
      });
    }
  }

  cleanUp() {
    this.launcher.interface.setup();
  }

}

exports.default = Watcher;