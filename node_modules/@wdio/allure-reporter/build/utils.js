"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLinkByTemplate = exports.getErrorFromFailedTest = exports.tellReporter = exports.isMochaAllHooks = exports.isMochaEachHooks = exports.isEmpty = exports.getTestStatus = void 0;

var _process = _interopRequireDefault(require("process"));

var _compoundError = _interopRequireDefault(require("./compoundError"));

var _constants = require("./constants");

var _stripAnsi = _interopRequireDefault(require("strip-ansi"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getTestStatus = (test, config) => {
  if (config.framework === 'jasmine') {
    return _constants.testStatuses.FAILED;
  }

  if (test.error.name && test.error.message) {
    const message = test.error.message.trim();
    return test.error.name === 'AssertionError' || message.includes('Expect') ? _constants.testStatuses.FAILED : _constants.testStatuses.BROKEN;
  }

  if (test.error.name) {
    return test.error.name === 'AssertionError' ? _constants.testStatuses.FAILED : _constants.testStatuses.BROKEN;
  }

  if (test.error.stack) {
    const stackTrace = test.error.stack.trim();
    return stackTrace.startsWith('AssertionError') || stackTrace.includes('Expect') ? _constants.testStatuses.FAILED : _constants.testStatuses.BROKEN;
  }

  return _constants.testStatuses.BROKEN;
};

exports.getTestStatus = getTestStatus;

const isEmpty = object => !object || Object.keys(object).length === 0;

exports.isEmpty = isEmpty;

const isMochaEachHooks = title => _constants.mochaEachHooks.some(hook => title.includes(hook));

exports.isMochaEachHooks = isMochaEachHooks;

const isMochaAllHooks = title => _constants.mochaAllHooks.some(hook => title.includes(hook));

exports.isMochaAllHooks = isMochaAllHooks;

const tellReporter = (event, msg = {}) => {
  _process.default.emit(event, msg);
};

exports.tellReporter = tellReporter;

const getErrorFromFailedTest = test => {
  if (test.errors && Array.isArray(test.errors)) {
    for (let i = 0; i < test.errors.length; i += 1) {
      if (test.errors[i].message) test.errors[i].message = (0, _stripAnsi.default)(test.errors[i].message);
      if (test.errors[i].stack) test.errors[i].stack = (0, _stripAnsi.default)(test.errors[i].stack);
    }

    return test.errors.length === 1 ? test.errors[0] : new _compoundError.default(...test.errors);
  }

  if (test.error.message) test.error.message = (0, _stripAnsi.default)(test.error.message);
  if (test.error.stack) test.error.stack = (0, _stripAnsi.default)(test.error.stack);
  return test.error;
};

exports.getErrorFromFailedTest = getErrorFromFailedTest;

const getLinkByTemplate = (template, id) => {
  if (typeof template !== 'string') {
    return id;
  }

  if (!template.includes(_constants.linkPlaceholder)) {
    throw Error(`The link template "${template}" must contain ${_constants.linkPlaceholder} substring.`);
  }

  return template.replace(_constants.linkPlaceholder, id);
};

exports.getLinkByTemplate = getLinkByTemplate;