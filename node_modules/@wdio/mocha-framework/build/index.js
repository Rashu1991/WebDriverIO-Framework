"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adapterFactory = exports.MochaAdapter = exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _mocha = _interopRequireDefault(require("mocha"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _utils = require("@wdio/utils");

var _utils2 = require("./utils");

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const log = (0, _logger.default)('@wdio/mocha-framework');
const MOCHA_UI_TYPE_EXTRACTOR = /^(?:.*-)?([^-.]+)(?:.js)?$/;
const DEFAULT_INTERFACE_TYPE = 'bdd';

class MochaAdapter {
  constructor(cid, config, specs, capabilities, reporter) {
    this.cid = cid;
    this.capabilities = capabilities;
    this.reporter = reporter;
    this.specs = specs;
    this.config = Object.assign({
      mochaOpts: {}
    }, config);
    this.runner = {};
    this.level = 0;
    this.suiteCnt = new Map();
    this.hookCnt = new Map();
    this.testCnt = new Map();
    this.suiteIds = ['0'];
    this._hasTests = true;
  }

  async init() {
    const {
      mochaOpts
    } = this.config;
    const mocha = this.mocha = new _mocha.default(mochaOpts);
    mocha.loadFiles();
    mocha.reporter(_constants.NOOP);
    mocha.fullTrace();
    this.specs.forEach(spec => mocha.addFile(spec));
    mocha.suite.on('pre-require', this.preRequire.bind(this));

    this._loadFiles(mochaOpts);

    return this;
  }

  _loadFiles(mochaOpts) {
    try {
      this.mocha.loadFiles();
      const mochaRunner = new _mocha.default.Runner(this.mocha.suite);

      if (mochaOpts.grep) {
        mochaRunner.grep(this.mocha.options.grep, mochaOpts.invert);
      }

      this._hasTests = mochaRunner.total > 0;
    } catch (err) {
      log.warn('Unable to load spec files quite likely because they rely on `browser` object that is not fully initialised.\n' + '`browser` object has only `capabilities` and some flags like `isMobile`.\n' + 'Helper files that use other `browser` commands have to be moved to `before` hook.\n' + `Spec file(s): ${this.specs.join(',')}\n`, 'Error: ', err);
    }
  }

  hasTests() {
    return this._hasTests;
  }

  async run() {
    const mocha = this.mocha;

    const {
      setOptions
    } = require('expect-webdriverio');

    setOptions({
      wait: this.config.waitforTimeout,
      interval: this.config.waitforInterval
    });
    let runtimeError;
    const result = await new Promise(resolve => {
      try {
        this.runner = mocha.run(resolve);
      } catch (e) {
        runtimeError = e;
        return resolve(1);
      }

      Object.keys(_constants.EVENTS).forEach(e => this.runner.on(e, this.emit.bind(this, _constants.EVENTS[e])));
      this.runner.suite.beforeAll(this.wrapHook('beforeSuite'));
      this.runner.suite.afterAll(this.wrapHook('afterSuite'));
    });
    await (0, _utils.executeHooksWithArgs)(this.config.after, [runtimeError || result, this.capabilities, this.specs]);

    if (runtimeError) {
      throw runtimeError;
    }

    return result;
  }

  options(options, context) {
    let {
      require = [],
      compilers = []
    } = options;

    if (typeof require === 'string') {
      require = [require];
    }

    this.requireExternalModules([...compilers, ...require], context);
  }

  preRequire(context, file, mocha) {
    const options = this.config.mochaOpts;
    const match = MOCHA_UI_TYPE_EXTRACTOR.exec(options.ui);
    const type = match && _constants.INTERFACES[match[1]] && match[1] || DEFAULT_INTERFACE_TYPE;

    const hookArgsFn = context => {
      return [_objectSpread(_objectSpread({}, context.test), {}, {
        parent: context.test.parent.title
      }), context];
    };

    _constants.INTERFACES[type].forEach(fnName => {
      let testCommand = _constants.INTERFACES[type][0];
      const isTest = [testCommand, testCommand + '.only'].includes(fnName);
      (0, _utils.runTestInFiberContext)(isTest, isTest ? this.config.beforeTest : this.config.beforeHook, hookArgsFn, isTest ? this.config.afterTest : this.config.afterHook, hookArgsFn, fnName, this.cid);
    });

    this.options(options, {
      context,
      file,
      mocha,
      options
    });
  }

  wrapHook(hookName) {
    return () => (0, _utils.executeHooksWithArgs)(this.config[hookName], this.prepareMessage(hookName)).catch(e => {
      log.error(`Error in ${hookName} hook: ${e.stack.slice(7)}`);
    });
  }

  prepareMessage(hookName) {
    const params = {
      type: hookName
    };

    switch (hookName) {
      case 'beforeSuite':
      case 'afterSuite':
        params.payload = this.runner.suite.suites[0];
        break;

      case 'beforeTest':
      case 'afterTest':
        params.payload = this.runner.test;
        break;
    }

    params.err = this.lastError;
    delete this.lastError;
    return this.formatMessage(params);
  }

  formatMessage(params) {
    let message = {
      type: params.type
    };

    if (params.err) {
      message.error = {
        message: params.err.message,
        stack: params.err.stack,
        type: params.err.type || params.err.name,
        expected: params.err.expected,
        actual: params.err.actual
      };

      if (params.payload && params.payload.title && params.payload.title.match(/^"(before|after)( all| each)?" hook/)) {
        message.type = 'hook:end';
      }
    }

    if (params.payload) {
      message.title = params.payload.title;
      message.parent = params.payload.parent ? params.payload.parent.title : null;
      message.fullTitle = params.payload.fullTitle ? params.payload.fullTitle() : message.parent + ' ' + message.title;
      message.pending = params.payload.pending || false;
      message.file = params.payload.file;
      message.duration = params.payload.duration;

      if (params.payload.ctx && params.payload.ctx.currentTest) {
        message.currentTest = params.payload.ctx.currentTest.title;
      }

      if (params.type.match(/Test/)) {
        message.passed = params.payload.state === 'passed';
      }

      if (params.payload.context) {
        message.context = params.payload.context;
      }
    }

    return message;
  }

  requireExternalModules(modules, context) {
    modules.forEach(module => {
      if (!module) {
        return;
      }

      module = module.replace(/.*:/, '');

      if (module.substr(0, 1) === '.') {
        module = _path.default.join(process.cwd(), module);
      }

      (0, _utils2.loadModule)(module, context);
    });
  }

  emit(event, payload, err) {
    if (payload.root) return;
    let message = this.formatMessage({
      type: event,
      payload,
      err
    });
    message.cid = this.cid;
    message.specs = this.specs;
    message.uid = this.getUID(message);

    if (message.error) {
      this.lastError = message.error;
    }

    this.reporter.emit(message.type, message);
  }

  getSyncEventIdStart(type) {
    const prop = `${type}Cnt`;
    const suiteId = this.suiteIds[this.suiteIds.length - 1];
    const cnt = this[prop].has(suiteId) ? this[prop].get(suiteId) : 0;
    this[prop].set(suiteId, cnt + 1);
    return `${type}-${suiteId}-${cnt}`;
  }

  getSyncEventIdEnd(type) {
    const prop = `${type}Cnt`;
    const suiteId = this.suiteIds[this.suiteIds.length - 1];
    const cnt = this[prop].get(suiteId) - 1;
    return `${type}-${suiteId}-${cnt}`;
  }

  getUID(message) {
    if (message.type === 'suite:start') {
      const suiteCnt = this.suiteCnt.has(this.level) ? this.suiteCnt.get(this.level) : 0;
      const suiteId = `suite-${this.level}-${suiteCnt}`;

      if (this.suiteCnt.has(this.level)) {
        this.suiteCnt.set(this.level, this.suiteCnt.get(this.level) + 1);
      } else {
        this.suiteCnt.set(this.level, 1);
      }

      this.suiteIds.push(`${this.level}${suiteCnt}`);
      this.level++;
      return suiteId;
    }

    if (message.type === 'suite:end') {
      this.level--;
      const suiteCnt = this.suiteCnt.get(this.level) - 1;
      const suiteId = `suite-${this.level}-${suiteCnt}`;
      this.suiteIds.pop();
      return suiteId;
    }

    if (message.type === 'hook:start') {
      return this.getSyncEventIdStart('hook');
    }

    if (message.type === 'hook:end') {
      return this.getSyncEventIdEnd('hook');
    }

    if (['test:start', 'test:pending'].includes(message.type)) {
      return this.getSyncEventIdStart('test');
    }

    if (['test:end', 'test:pass', 'test:fail'].includes(message.type)) {
      return this.getSyncEventIdEnd('test');
    }

    throw new Error(`Unknown message type : ${message.type}`);
  }

}

exports.MochaAdapter = MochaAdapter;
const adapterFactory = {};
exports.adapterFactory = adapterFactory;

adapterFactory.init = async function (...args) {
  const adapter = new MochaAdapter(...args);
  const instance = await adapter.init();
  return instance;
};

var _default = adapterFactory;
exports.default = _default;