"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _util = require("util");

var _events = _interopRequireDefault(require("events"));

var _utils = require("./utils");

var _suite = _interopRequireDefault(require("./stats/suite"));

var _hook = _interopRequireDefault(require("./stats/hook"));

var _test = _interopRequireDefault(require("./stats/test"));

var _runner = _interopRequireDefault(require("./stats/runner"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class WDIOReporter extends _events.default {
  constructor(options) {
    super();
    this.options = options;

    if (this.options.outputDir) {
      _fsExtra.default.ensureDirSync(this.options.outputDir);
    }

    this.outputStream = this.options.stdout || !this.options.logFile ? options.writeStream : _fs.default.createWriteStream(this.options.logFile);
    this.failures = [];
    this.suites = {};
    this.hooks = {};
    this.tests = {};
    this.currentSuites = [];
    this.counts = {
      suites: 0,
      tests: 0,
      hooks: 0,
      passes: 0,
      skipping: 0,
      failures: 0
    };
    let currentTest;
    const rootSuite = new _suite.default({
      title: '(root)',
      fullTitle: '(root)'
    });
    this.currentSuites.push(rootSuite);
    this.on('client:beforeCommand', this.onBeforeCommand.bind(this));
    this.on('client:afterCommand', this.onAfterCommand.bind(this));
    this.on('runner:start', runner => {
      rootSuite.cid = runner.cid;
      this.runnerStat = new _runner.default(runner);
      this.onRunnerStart(this.runnerStat);
    });
    this.on('suite:start', params => {
      const suite = new _suite.default(params);
      const currentSuite = this.currentSuites[this.currentSuites.length - 1];
      currentSuite.suites.push(suite);
      this.currentSuites.push(suite);
      this.suites[suite.uid] = suite;
      this.onSuiteStart(suite);
    });
    this.on('hook:start', hook => {
      const hookStat = new _hook.default(hook);
      const currentSuite = this.currentSuites[this.currentSuites.length - 1];
      currentSuite.hooks.push(hookStat);
      currentSuite.hooksAndTests.push(hookStat);
      this.hooks[hook.uid] = hookStat;
      this.onHookStart(hookStat);
    });
    this.on('hook:end', hook => {
      const hookStat = this.hooks[hook.uid];
      hookStat.complete((0, _utils.getErrorsFromEvent)(hook));
      this.counts.hooks++;
      this.onHookEnd(hookStat);
    });
    this.on('test:start', test => {
      currentTest = new _test.default(test);
      const currentSuite = this.currentSuites[this.currentSuites.length - 1];
      currentSuite.tests.push(currentTest);
      currentSuite.hooksAndTests.push(currentTest);
      this.tests[test.uid] = currentTest;
      this.onTestStart(currentTest);
    });
    this.on('test:pass', test => {
      const testStat = this.tests[test.uid];
      testStat.pass();
      this.counts.passes++;
      this.counts.tests++;
      this.onTestPass(testStat);
    });
    this.on('test:fail', test => {
      const testStat = this.tests[test.uid];

      if (test.error && test.error.message && test.error.message.includes(_constants.MOCHA_TIMEOUT_MESSAGE)) {
        let replacement = (0, _util.format)(_constants.MOCHA_TIMEOUT_MESSAGE_REPLACEMENT, test.parent, test.title);
        test.error.message = test.error.message.replace(_constants.MOCHA_TIMEOUT_MESSAGE, replacement);
        test.error.stack = test.error.stack.replace(_constants.MOCHA_TIMEOUT_MESSAGE, replacement);
      }

      testStat.fail((0, _utils.getErrorsFromEvent)(test));
      this.counts.failures++;
      this.counts.tests++;
      this.onTestFail(testStat);
    });
    this.on('test:pending', test => {
      const currentSuite = this.currentSuites[this.currentSuites.length - 1];
      currentTest = new _test.default(test);

      if (test.uid in this.tests && this.tests[test.uid].state !== 'pending') {
        currentTest.uid = test.uid in this.tests ? 'skipped-' + this.counts.skipping : currentTest.uid;
      }

      const suiteTests = currentSuite.tests;

      if (!suiteTests.length || currentTest.uid !== suiteTests[suiteTests.length - 1].uid) {
        currentSuite.tests.push(currentTest);
        currentSuite.hooksAndTests.push(currentTest);
      } else {
        suiteTests[suiteTests.length - 1] = currentTest;
        currentSuite.hooksAndTests[currentSuite.hooksAndTests.length - 1] = currentTest;
      }

      this.tests[currentTest.uid] = currentTest;
      currentTest.skip(test.pendingReason);
      this.counts.skipping++;
      this.counts.tests++;
      this.onTestSkip(currentTest);
    });
    this.on('test:end', test => {
      const testStat = this.tests[test.uid];
      this.onTestEnd(testStat);
    });
    this.on('suite:end', suite => {
      const suiteStat = this.suites[suite.uid];
      suiteStat.complete();
      this.currentSuites.pop();
      this.onSuiteEnd(suiteStat);
    });
    this.on('runner:end', runner => {
      rootSuite.complete();
      this.runnerStat.failures = runner.failures;
      this.runnerStat.retries = runner.retries;
      this.runnerStat.complete();
      this.onRunnerEnd(this.runnerStat);
    });
    this.on('client:command', payload => {
      if (!currentTest) {
        return;
      }

      currentTest.output.push(Object.assign(payload, {
        type: 'command'
      }));
    });
    this.on('client:result', payload => {
      if (!currentTest) {
        return;
      }

      currentTest.output.push(Object.assign(payload, {
        type: 'result'
      }));
    });
  }

  get isSynchronised() {
    return true;
  }

  write(content) {
    this.outputStream.write(content);
  }

  onRunnerStart() {}

  onBeforeCommand() {}

  onAfterCommand() {}

  onScreenshot() {}

  onSuiteStart() {}

  onHookStart() {}

  onHookEnd() {}

  onTestStart() {}

  onTestPass() {}

  onTestFail() {}

  onTestSkip() {}

  onTestEnd() {}

  onSuiteEnd() {}

  onRunnerEnd() {}

}

exports.default = WDIOReporter;