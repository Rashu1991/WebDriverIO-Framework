"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _child_process = _interopRequireDefault(require("child_process"));

var _events = _interopRequireDefault(require("events"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _transformStream = _interopRequireDefault(require("./transformStream"));

var _replQueue = _interopRequireDefault(require("./replQueue"));

var _stdStream = _interopRequireDefault(require("./stdStream"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const log = (0, _logger.default)('@wdio/local-runner');
const replQueue = new _replQueue.default();
const stdOutStream = new _stdStream.default();
const stdErrStream = new _stdStream.default();
stdOutStream.pipe(process.stdout);
stdErrStream.pipe(process.stderr);

class WorkerInstance extends _events.default {
  constructor(config, {
    cid,
    configFile,
    caps,
    specs,
    execArgv,
    retries
  }, stdout, stderr) {
    super();
    this.cid = cid;
    this.config = config;
    this.configFile = configFile;
    this.caps = caps;
    this.specs = specs;
    this.execArgv = execArgv;
    this.retries = retries;
    this.isBusy = false;
    this.stdout = stdout;
    this.stderr = stderr;
  }

  startProcess() {
    const {
      cid,
      execArgv
    } = this;
    const argv = process.argv.slice(2);
    const runnerEnv = Object.assign({}, process.env, this.config.runnerEnv, {
      WDIO_WORKER: true
    });

    if (this.config.outputDir) {
      runnerEnv.WDIO_LOG_PATH = _path.default.join(this.config.outputDir, `wdio-${cid}.log`);
    }

    log.info(`Start worker ${cid} with arg: ${argv}`);

    const childProcess = this.childProcess = _child_process.default.fork(_path.default.join(__dirname, 'run.js'), argv, {
      cwd: process.cwd(),
      env: runnerEnv,
      execArgv,
      stdio: ['inherit', 'pipe', 'pipe', 'ipc']
    });

    childProcess.on('message', this._handleMessage.bind(this));
    childProcess.on('error', this._handleError.bind(this));
    childProcess.on('exit', this._handleExit.bind(this));

    if (!process.env.JEST_WORKER_ID) {
      childProcess.stdout.pipe(new _transformStream.default(cid)).pipe(stdOutStream);
      childProcess.stderr.pipe(new _transformStream.default(cid)).pipe(stdErrStream);
    }

    return childProcess;
  }

  _handleMessage(payload) {
    const {
      cid,
      childProcess
    } = this;

    if (payload.name === 'finisedCommand') {
      this.isBusy = false;
    }

    if (payload.name === 'sessionStarted') {
      if (payload.content.isMultiremote) {
        Object.assign(this, payload.content);
      } else {
        this.sessionId = payload.content.sessionId;
        delete payload.content.sessionId;
      }

      return;
    }

    if (payload.origin === 'debugger' && payload.name === 'start') {
      replQueue.add(childProcess, _objectSpread({
        prompt: `[${cid}] \u203A `
      }, payload.params), () => this.emit('message', Object.assign(payload, {
        cid
      })), ev => this.emit('message', ev));
      return replQueue.next();
    }

    if (replQueue.isRunning && payload.origin === 'debugger' && payload.name === 'result') {
      replQueue.runningRepl.onResult(payload.params);
    }

    this.emit('message', Object.assign(payload, {
      cid
    }));
  }

  _handleError(payload) {
    const {
      cid
    } = this;
    this.emit('error', Object.assign(payload, {
      cid
    }));
  }

  _handleExit(exitCode) {
    const {
      cid,
      childProcess,
      specs,
      retries
    } = this;
    delete this.childProcess;
    this.isBusy = false;
    log.debug(`Runner ${cid} finished with exit code ${exitCode}`);
    this.emit('exit', {
      cid,
      exitCode,
      specs,
      retries
    });
    childProcess.kill('SIGTERM');
  }

  postMessage(command, args) {
    const {
      cid,
      configFile,
      caps,
      specs,
      retries,
      isBusy
    } = this;

    if (isBusy && command !== 'endSession') {
      return log.info(`worker with cid ${cid} already busy and can't take new commands`);
    }

    if (!this.childProcess) {
      this.childProcess = this.startProcess();
    }

    this.childProcess.send({
      cid,
      command,
      configFile,
      args,
      caps,
      specs,
      retries
    });
    this.isBusy = true;
  }

}

exports.default = WorkerInstance;