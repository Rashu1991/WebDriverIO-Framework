"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _util = _interopRequireDefault(require("util"));

var _events = _interopRequireDefault(require("events"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _utils = require("@wdio/utils");

var _config = require("@wdio/config");

var _reporter = _interopRequireDefault(require("./reporter"));

var _utils2 = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const log = (0, _logger.default)('@wdio/runner');

class Runner extends _events.default {
  constructor() {
    super();
    this.configParser = new _config.ConfigParser();
    this.sigintWasCalled = false;
  }

  async run({
    cid,
    args,
    specs,
    caps,
    configFile,
    retries
  }) {
    var _context;

    this.cid = cid;
    this.specs = specs;
    this.caps = caps;

    try {
      this.configParser.addConfigFile(configFile);
    } catch (e) {
      return this._shutdown(1);
    }

    this.configParser.merge(args);
    this.config = this.configParser.getConfig();
    this.config.specFileRetryAttempts = (this.config.specFileRetries || 0) - (retries || 0);

    _logger.default.setLogLevelsConfig(this.config.logLevels, this.config.logLevel);

    const isMultiremote = this.isMultiremote = !Array.isArray(this.configParser.getCapabilities());
    let browser = await this._startSession(_objectSpread(_objectSpread({}, this.config), {}, {
      _automationProtocol: this.config.automationProtocol,
      automationProtocol: './protocol-stub'
    }), caps);
    this.reporter = new _reporter.default(this.config, this.cid, _objectSpread({}, caps));
    this.framework = (0, _utils.initialisePlugin)(this.config.framework, 'framework').default;
    this.framework = await this.framework.init(cid, this.config, specs, caps, this.reporter);
    process.send({
      name: 'testFrameworkInit',
      content: {
        cid,
        caps,
        specs,
        hasTests: this.framework.hasTests()
      }
    });

    if (!this.framework.hasTests()) {
      return this._shutdown(0);
    }

    (0, _utils.initialiseWorkerService)(this.config, caps, args.ignoredWorkerServices).map((_context = this.configParser).addService.bind(_context));
    await (0, _utils2.runHook)('beforeSession', this.config, this.caps, this.specs);
    browser = await this._initSession(this.config, this.caps, browser);
    this.inWatchMode = Boolean(this.config.watch);

    if (!browser) {
      return this._shutdown(1);
    }

    this.reporter.caps = browser.capabilities;
    await (0, _utils.executeHooksWithArgs)(this.config.before, [this.caps, this.specs]);

    if (this.sigintWasCalled) {
      log.info('SIGINT signal detected while starting session, shutting down...');
      await this.endSession();
      return this._shutdown(0);
    }

    const instances = (0, _utils2.getInstancesData)(browser, isMultiremote);
    this.reporter.emit('runner:start', {
      cid,
      specs,
      config: this.config,
      isMultiremote,
      sessionId: browser.sessionId,
      capabilities: isMultiremote ? browser.instances.reduce((caps, browserName) => {
        caps[browserName] = browser[browserName].capabilities;
        caps[browserName].sessionId = browser[browserName].sessionId;
        return caps;
      }, {}) : _objectSpread(_objectSpread({}, browser.capabilities), {}, {
        sessionId: browser.sessionId
      }),
      retry: this.config.specFileRetryAttempts
    });
    const {
      protocol,
      hostname,
      port,
      path,
      queryParams
    } = browser.options;
    const {
      isW3C,
      sessionId
    } = browser;
    process.send({
      origin: 'worker',
      name: 'sessionStarted',
      content: {
        sessionId,
        isW3C,
        protocol,
        hostname,
        port,
        path,
        queryParams,
        isMultiremote,
        instances
      }
    });
    let failures = 0;

    try {
      failures = await this.framework.run();
      await this._fetchDriverLogs(this.config, caps.excludeDriverLogs);
    } catch (e) {
      log.error(e);
      this.emit('error', e);
      failures = 1;
    }

    if (!args.watch) {
      await this.endSession();
    }

    this.reporter.emit('runner:end', {
      failures,
      cid: this.cid,
      retries
    });
    return this._shutdown(failures);
  }

  async _initSession(config, caps, browserStub) {
    const browser = await this._startSession(config, caps);

    if (!browser) {
      return null;
    }

    if (browserStub) {
      Object.entries(browserStub).forEach(([key, value]) => {
        if (typeof browser[key] === 'undefined') {
          browser[key] = value;
        }
      });
    }

    global.$ = selector => browser.$(selector);

    global.$$ = selector => browser.$$(selector);

    browser.on('command', command => this.reporter.emit('client:beforeCommand', Object.assign(command, {
      sessionId: browser.sessionId
    })));
    browser.on('result', result => this.reporter.emit('client:afterCommand', Object.assign(result, {
      sessionId: browser.sessionId
    })));
    return browser;
  }

  async _startSession(config, caps) {
    let browser = null;

    try {
      browser = global.browser = global.driver = await (0, _utils2.initialiseInstance)(config, caps, this.isMultiremote);
    } catch (e) {
      log.error(e);
      this.emit('error', e);
      return browser;
    }

    browser.config = config;
    return browser;
  }

  async _fetchDriverLogs(config, excludeDriverLogs) {
    if (!config.outputDir || !global.browser.sessionId || typeof global.browser.getLogs === 'undefined') {
      return;
    }

    global._HAS_FIBER_CONTEXT = true;
    let logTypes;

    try {
      logTypes = await global.browser.getLogTypes();
    } catch (errIgnored) {
      return;
    }

    logTypes = (0, _utils2.filterLogTypes)(excludeDriverLogs, logTypes);
    log.debug(`Fetching logs for ${logTypes.join(', ')}`);
    return Promise.all(logTypes.map(async logType => {
      let logs;

      try {
        logs = await global.browser.getLogs(logType);
      } catch (e) {
        return log.warn(`Couldn't fetch logs for ${logType}: ${e.message}`);
      }

      if (logs.length === 0) {
        return;
      }

      const stringLogs = logs.map(log => JSON.stringify(log)).join('\n');
      return _util.default.promisify(_fs.default.writeFile)(_path.default.join(config.outputDir, `wdio-${this.cid}-${logType}.log`), stringLogs, 'utf-8');
    }));
  }

  async _shutdown(failures) {
    try {
      await this.reporter.waitForSync();
    } catch (e) {
      log.error(e);
    }

    this.emit('exit', failures === 0 ? 0 : 1);
    return failures;
  }

  async endSession() {
    const hasSessionId = global.browser && (this.isMultiremote ? !global.browser.instances.some(i => global.browser[i] && !global.browser[i].sessionId) : global.browser.sessionId);

    if (!hasSessionId) {
      return;
    }

    let capabilities = global.browser.capabilities || {};

    if (this.isMultiremote) {
      global.browser.instances.forEach(i => {
        capabilities[i] = global.browser[i].capabilities;
      });
    }

    await global.browser.deleteSession();

    if (this.isMultiremote) {
      global.browser.instances.forEach(i => {
        delete global.browser[i].sessionId;
      });
    } else {
      delete global.browser.sessionId;
    }

    await (0, _utils2.runHook)('afterSession', global.browser.config, capabilities, this.specs);
  }

}

exports.default = Runner;