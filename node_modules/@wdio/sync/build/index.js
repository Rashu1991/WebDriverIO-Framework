"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runSync = runSync;
exports.default = sync;
Object.defineProperty(exports, "executeHooksWithArgs", {
  enumerable: true,
  get: function () {
    return _executeHooksWithArgs.default;
  }
});
Object.defineProperty(exports, "runFnInFiberContext", {
  enumerable: true,
  get: function () {
    return _runFnInFiberContext.default;
  }
});
Object.defineProperty(exports, "wrapCommand", {
  enumerable: true,
  get: function () {
    return _wrapCommand.default;
  }
});
exports.executeSync = void 0;

var _fibers = _interopRequireDefault(require("./fibers"));

var _executeHooksWithArgs = _interopRequireDefault(require("./executeHooksWithArgs"));

var _runFnInFiberContext = _interopRequireDefault(require("./runFnInFiberContext"));

var _wrapCommand = _interopRequireDefault(require("./wrapCommand"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaultRetries = {
  attempts: 0,
  limit: 0
};

const executeSync = async function (fn, retries = defaultRetries, args = []) {
  if (global.browser) {
    delete global.browser._NOT_FIBER;
  }

  if (this) {
    this.wdioRetries = retries.attempts;
  }

  try {
    global._HAS_FIBER_CONTEXT = true;
    let res = fn.apply(this, args);
    global._HAS_FIBER_CONTEXT = false;

    if (res instanceof Promise) {
      return await res;
    }

    return res;
  } catch (e) {
    if (retries.limit > retries.attempts) {
      retries.attempts++;
      return await executeSync.call(this, fn, retries, args);
    }

    if (!e.stack) {
      return Promise.reject(e);
    }

    e.stack = e.stack.split('\n').filter(_constants.STACKTRACE_FILTER_FN).join('\n');
    return Promise.reject(e);
  }
};

exports.executeSync = executeSync;

function runSync(fn, repeatTest = 0, args = []) {
  return (resolve, reject) => (0, _fibers.default)(() => executeSync.call(this, fn, repeatTest, args).then(resolve, reject)).run();
}

function sync(testFn) {
  return new Promise((resolve, reject) => {
    return runSync(testFn)(resolve, reject);
  });
}