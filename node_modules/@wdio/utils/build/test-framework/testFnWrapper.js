"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testFrameworkFnWrapper = exports.testFnWrapper = void 0;

var _utils = require("../utils");

var _errorHandler = require("./errorHandler");

var _shim = require("../shim");

const testFnWrapper = function (...args) {
  return testFrameworkFnWrapper.call(this, {
    executeHooksWithArgs: _shim.executeHooksWithArgs,
    executeAsync: _shim.executeAsync,
    runSync: _shim.runSync
  }, ...args);
};

exports.testFnWrapper = testFnWrapper;

const testFrameworkFnWrapper = async function ({
  executeHooksWithArgs,
  executeAsync,
  runSync
}, type, {
  specFn,
  specFnArgs
}, {
  beforeFn,
  beforeFnArgs
}, {
  afterFn,
  afterFnArgs
}, cid, repeatTest = 0) {
  const retries = {
    attempts: 0,
    limit: repeatTest
  };
  const beforeArgs = beforeFnArgs(this);
  await (0, _errorHandler.logHookError)(`Before${type}`, await executeHooksWithArgs(beforeFn, beforeArgs), cid);
  let promise;
  let result;
  let error;

  if ((0, _utils.isFunctionAsync)(specFn) || !runSync) {
    promise = executeAsync.call(this, specFn, retries, specFnArgs);
  } else {
    promise = new Promise(runSync.call(this, specFn, retries, specFnArgs));
  }

  const testStart = Date.now();

  try {
    result = await promise;
  } catch (err) {
    error = err;
  }

  const duration = Date.now() - testStart;
  let afterArgs = afterFnArgs(this);

  if (!error && afterArgs[0] && afterArgs[0].failedExpectations && afterArgs[0].failedExpectations.length) {
    error = afterArgs[0].failedExpectations[0];
  }

  afterArgs.push({
    retries,
    error,
    result,
    duration,
    passed: !error
  });
  await (0, _errorHandler.logHookError)(`After${type}`, await executeHooksWithArgs(afterFn, [...afterArgs]), cid);

  if (error) {
    throw error;
  }

  return result;
};

exports.testFrameworkFnWrapper = testFrameworkFnWrapper;