"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _http = _interopRequireDefault(require("http"));

var _https = _interopRequireDefault(require("https"));

var _events = _interopRequireDefault(require("events"));

var _got = _interopRequireDefault(require("got"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _utils = require("@wdio/utils");

var _utils2 = require("./utils");

var _package = _interopRequireDefault(require("../package.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const DEFAULT_HEADERS = {
  'Connection': 'keep-alive',
  'Accept': 'application/json',
  'User-Agent': 'webdriver/' + _package.default.version
};
const log = (0, _logger.default)('webdriver');
const agents = {
  http: new _http.default.Agent({
    keepAlive: true
  }),
  https: new _https.default.Agent({
    keepAlive: true
  })
};

class WebDriverRequest extends _events.default {
  constructor(method, endpoint, body, isHubCommand) {
    super();
    this.body = body;
    this.method = method;
    this.endpoint = endpoint;
    this.isHubCommand = isHubCommand;
    this.requiresSessionId = this.endpoint.match(/:sessionId/);
    this.defaultOptions = {
      method,
      retry: 0,
      followRedirect: true,
      responseType: 'json',
      throwHttpErrors: false
    };
  }

  makeRequest(options, sessionId) {
    let fullRequestOptions = Object.assign({}, this.defaultOptions, this._createOptions(options, sessionId));

    if (typeof options.transformRequest === 'function') {
      fullRequestOptions = options.transformRequest(fullRequestOptions);
    }

    this.emit('request', fullRequestOptions);
    return this._request(fullRequestOptions, options.transformResponse, options.connectionRetryCount, 0);
  }

  _createOptions(options, sessionId) {
    const requestOptions = {
      agent: options.agent || agents,
      headers: _objectSpread(_objectSpread({}, DEFAULT_HEADERS), typeof options.headers === 'object' ? options.headers : {}),
      searchParams: typeof options.queryParams === 'object' ? options.queryParams : {},
      timeout: options.connectionRetryTimeout
    };

    if (this.body && (Object.keys(this.body).length || this.method === 'POST')) {
      const contentLength = Buffer.byteLength(JSON.stringify(this.body), 'utf8');
      requestOptions.json = this.body;
      requestOptions.headers['Content-Length'] = contentLength;
    }

    if (this.requiresSessionId && !sessionId) {
      throw new Error('A sessionId is required for this command');
    }

    requestOptions.uri = new URL(`${options.protocol}://` + `${options.hostname}:${options.port}` + (this.isHubCommand ? this.endpoint : _path.default.join(options.path, this.endpoint.replace(':sessionId', sessionId))));

    if (this.endpoint === '/session' && options.user && options.key) {
      requestOptions.username = options.user;
      requestOptions.password = options.key;
    }

    requestOptions.rejectUnauthorized = !(process.env.STRICT_SSL === 'false' || process.env.strict_ssl === 'false');
    return requestOptions;
  }

  async _request(fullRequestOptions, transformResponse, totalRetryCount = 0, retryCount = 0) {
    log.info(`[${fullRequestOptions.method}] ${fullRequestOptions.uri.href}`);

    if (fullRequestOptions.json && Object.keys(fullRequestOptions.json).length) {
      log.info('DATA', (0, _utils.transformCommandLogResult)(fullRequestOptions.json));
    }

    const retry = (error, msg) => {
      if (retryCount >= totalRetryCount || error.message.includes('invalid session id')) {
        log.error(`Request failed with status ${response.statusCode} due to ${error}`);
        this.emit('response', {
          error
        });
        error.statusCode = response.statusCode;
        error.statusMessage = response.statusMessage;
        throw error;
      }

      ++retryCount;
      this.emit('retry', {
        error,
        retryCount
      });
      log.warn(msg);
      log.info(`Retrying ${retryCount}/${totalRetryCount}`);
      return this._request(fullRequestOptions, transformResponse, totalRetryCount, retryCount);
    };

    let response = await (0, _got.default)(fullRequestOptions.uri, _objectSpread({}, fullRequestOptions)).catch(err => err);

    if (response instanceof Error) {
      if (response.code === 'ETIMEDOUT') {
        return retry(response, 'Request timed out! Consider increasing the "connectionRetryTimeout" option.');
      }

      throw response;
    }

    if (typeof transformResponse === 'function') {
      response = transformResponse(response, fullRequestOptions);
    }

    const error = (0, _utils2.getErrorFromResponseBody)(response.body);

    if (this.isHubCommand) {
      if (typeof response.body === 'string' && response.body.startsWith('<!DOCTYPE html>')) {
        return Promise.reject(new Error('Command can only be called to a Selenium Hub'));
      }

      return {
        value: response.body || null
      };
    }

    if ((0, _utils2.isSuccessfulResponse)(response.statusCode, response.body)) {
      this.emit('response', {
        result: response.body
      });
      return response.body;
    }

    if (error.name === 'stale element reference') {
      log.warn('Request encountered a stale element - terminating request');
      this.emit('response', {
        error
      });
      throw error;
    }

    return retry(error, `Request failed with status ${response.statusCode} due to ${error.message}`);
  }

}

exports.default = WebDriverRequest;