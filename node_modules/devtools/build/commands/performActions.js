"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = performActions;

var _USKeyboardLayout = require("puppeteer-core/lib/USKeyboardLayout");

var _getElementRect = _interopRequireDefault(require("./getElementRect"));

var _constants = require("../constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const KEY = 'key';
const POINTER = 'pointer';

const sleep = (time = 0) => new Promise(resolve => setTimeout(resolve, time));

async function performActions({
  actions
}) {
  const page = this.getPageHandle();
  const lastPointer = {};

  for (const action of actions) {
    if (action.type === null || action.type === 'null') {
      for (const singleAction of action.actions) {
        await sleep(singleAction.duration);
      }

      continue;
    }

    if (action.type === 'key') {
      const skipChars = [];

      for (const singleAction of action.actions) {
        var _context;

        if (singleAction.type === 'pause') {
          await sleep(singleAction.duration);
          continue;
        }

        const cmd = singleAction.type.slice(KEY.length).toLowerCase();

        const keyboardFn = (_context = page.keyboard)[cmd].bind(_context);

        if (cmd === 'up' && skipChars[0] === singleAction.value) {
          skipChars.shift();
          continue;
        }

        if (!_USKeyboardLayout.keyDefinitions[singleAction.value]) {
          await page.keyboard.sendCharacter(singleAction.value);
          skipChars.push(singleAction.value);
          continue;
        }

        await keyboardFn(singleAction.value);
        continue;
      }

      continue;
    }

    if (action.type === 'pointer') {
      if (action.parameters && action.parameters.pointerType && action.parameters.pointerType !== 'mouse') {
        throw new Error('Currently only "mouse" is supported as pointer type');
      }

      for (const singleAction of action.actions) {
        var _context2;

        if (singleAction.type === 'pause') {
          await sleep(singleAction.duration);
          continue;
        }

        const cmd = singleAction.type.slice(POINTER.length).toLowerCase();

        const keyboardFn = (_context2 = page.mouse)[cmd].bind(_context2);

        let {
          x,
          y,
          duration,
          button,
          origin
        } = singleAction;

        if (cmd === 'move') {
          if (origin === 'pointer' && lastPointer.x && lastPointer.y) {
            x += lastPointer.x;
            y += lastPointer.y;
          }

          if (origin && typeof origin[_constants.ELEMENT_KEY] === 'string' && typeof x === 'number' && typeof y === 'number') {
            const elemRect = await _getElementRect.default.call(this, {
              elementId: origin[_constants.ELEMENT_KEY]
            });
            x += elemRect.x + elemRect.width / 2;
            y += elemRect.y + elemRect.height / 2;
          }

          lastPointer.x = x;
          lastPointer.y = y;
          await keyboardFn(x, y, {
            steps: 10
          });
          continue;
        } else {
          const pptrButton = button === 1 ? 'middle' : button === 2 ? 'right' : 'left';
          await keyboardFn({
            button: pptrButton
          });
        }

        if (duration) {
          await sleep(duration);
        }

        continue;
      }

      continue;
    }

    throw new Error(`Unknown action type ("${action.type}"), allowed are only: null, key and pointer`);
  }
}