"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "SUPPORTED_BROWSER", {
  enumerable: true,
  get: function () {
    return _constants.SUPPORTED_BROWSER;
  }
});
exports.default = exports.sessionMap = void 0;

var _os = _interopRequireDefault(require("os"));

var _uaParserJs = _interopRequireDefault(require("ua-parser-js"));

var _uuid = require("uuid");

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _utils = require("@wdio/utils");

var _config = require("@wdio/config");

var _devtoolsdriver = _interopRequireDefault(require("./devtoolsdriver"));

var _launcher = _interopRequireDefault(require("./launcher"));

var _constants = require("./constants");

var _utils2 = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const log = (0, _logger.default)('devtools:puppeteer');
(0, _utils2.patchDebug)(log);
const sessionMap = new Map();
exports.sessionMap = sessionMap;

class DevTools {
  static async newSession(options = {}, modifier, userPrototype = {}, customCommandWrapper) {
    const params = (0, _config.validateConfig)(_constants.DEFAULTS, options);

    if (!options.logLevels || !options.logLevels['devtools']) {
      _logger.default.setLevel('devtools', params.logLevel);
    }

    const browser = await (0, _launcher.default)(params.capabilities);
    const pages = await browser.pages();
    const driver = new _devtoolsdriver.default(browser, pages);
    const sessionId = (0, _uuid.v4)();
    const userAgent = (0, _uaParserJs.default)(await browser.userAgent());
    const availableVendorPrefixes = Object.values(_constants.VENDOR_PREFIX);
    const vendorCapPrefix = Object.keys(params.capabilities).find(capKey => availableVendorPrefixes.includes(capKey));
    params.requestedCapabilities = _objectSpread({}, params.capabilities);
    params.capabilities = {
      browserName: userAgent.browser.name,
      browserVersion: userAgent.browser.version,
      platformName: _os.default.platform(),
      platformVersion: _os.default.release(),
      [vendorCapPrefix]: Object.assign({
        debuggerAddress: browser._connection.url().split('/')[2]
      }, params.capabilities[vendorCapPrefix])
    };
    sessionMap.set(sessionId, {
      browser,
      session: driver
    });
    const environmentPrototype = {
      getPuppeteer: {
        value: () => browser
      }
    };
    Object.entries((0, _utils.devtoolsEnvironmentDetector)({
      browserName: userAgent.browser.name.toLowerCase()
    })).forEach(([name, value]) => {
      environmentPrototype[name] = {
        value
      };
    });

    const commandWrapper = (_, __, commandInfo) => driver.register(commandInfo);

    const protocolCommands = (0, _utils2.getPrototype)(commandWrapper);

    const prototype = _objectSpread(_objectSpread(_objectSpread({}, protocolCommands), environmentPrototype), userPrototype);

    const monad = (0, _utils.webdriverMonad)(params, modifier, prototype);
    return monad(sessionId, customCommandWrapper);
  }

  static async reloadSession(instance) {
    const {
      session
    } = sessionMap.get(instance.sessionId);
    const browser = await (0, _launcher.default)(instance.requestedCapabilities);
    const pages = await browser.pages();
    session.elementStore.clear();
    session.windows = new Map();
    session.browser = browser;

    for (const page of pages) {
      const pageId = (0, _uuid.v4)();
      session.windows.set(pageId, page);
      session.currentWindowHandle = pageId;
    }

    sessionMap.set(instance.sessionId, {
      browser,
      session
    });
    return instance.sessionId;
  }

  static attachToSession() {
    throw new Error('not yet implemented');
  }

}

exports.default = DevTools;